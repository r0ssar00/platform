
/*
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */

#ifndef __dbusxx__client_glue_h__PROXY_MARSHAL_H
#define __dbusxx__client_glue_h__PROXY_MARSHAL_H

#include <dbus-c++/dbus.h>

namespace com {
namespace ross {
namespace XTagRev {

class TagDB_proxy
 : public ::DBus::InterfaceProxy
{
public:

    TagDB_proxy()
    : ::DBus::InterfaceProxy("com.ross.XTagRev.TagDB")
    {
        connect_signal(TagDB_proxy, ReloadTagDB, _ReloadTagDB_stub);
    }

public:

    /* properties exported by this interface */
public:

    /* methods exported by this interface,
     * this functions will invoke the corresponding methods on the remote objects
     */
    void AddTag(const std::string& tagname)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << tagname;
        call.member("AddTag");
        ::DBus::Message ret = invoke_method(call);
    }

    void RmTag(const std::string& tagname)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << tagname;
        call.member("RmTag");
        ::DBus::Message ret = invoke_method(call);
    }

    bool LoadTags(const std::string& filename)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filename;
        call.member("LoadTags");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        bool argout;
        ri >> argout;
        return argout;
    }

    std::vector< std::string > GetTagNames()
    {
        ::DBus::CallMessage call;
        call.member("GetTagNames");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }

    std::vector< std::string > GetTagSizes()
    {
        ::DBus::CallMessage call;
        call.member("GetTagSizes");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }

    void ForceReloadTagDB()
    {
        ::DBus::CallMessage call;
        call.member("ForceReloadTagDB");
        ::DBus::Message ret = invoke_method(call);
    }


public:

    /* signal handlers for this interface
     */
    virtual void ReloadTagDB() = 0;

private:

    /* unmarshalers (to unpack the DBus message before calling the actual signal handler)
     */
    void _ReloadTagDB_stub(const ::DBus::SignalMessage &sig)
    {
        ReloadTagDB();
    }
};

} } } 
namespace com {
namespace ross {

class platform_proxy
 : public ::DBus::InterfaceProxy
{
public:

    platform_proxy()
    : ::DBus::InterfaceProxy("com.ross.platform")
    {
    }

public:

    /* properties exported by this interface */
public:

    /* methods exported by this interface,
     * this functions will invoke the corresponding methods on the remote objects
     */
    std::string GetTag(const std::string& filename)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filename;
        call.member("GetTag");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::string argout;
        ri >> argout;
        return argout;
    }

    std::vector< std::string > GetTags(const std::string& filename)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filename;
        call.member("GetTags");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }

    int32_t SetTag(const std::string& filename, const std::string& tag)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filename;
        wi << tag;
        call.member("SetTag");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    int32_t AddTag(const std::string& filename, const std::string& tag)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filename;
        wi << tag;
        call.member("AddTag");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    int32_t RmTag(const std::string& filename, const std::string& tag)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filename;
        wi << tag;
        call.member("RmTag");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    std::vector< std::string > Query(const std::string& query, const bool& throttle)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << query;
        wi << throttle;
        call.member("Query");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }

    std::vector< std::string > ExecuteQuery(const std::string& query, const bool& throttle)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << query;
        wi << throttle;
        call.member("ExecuteQuery");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }


public:

    /* signal handlers for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual signal handler)
     */
};

} } 
namespace com {
namespace ross {

class filesystem_proxy
 : public ::DBus::InterfaceProxy
{
public:

    filesystem_proxy()
    : ::DBus::InterfaceProxy("com.ross.filesystem")
    {
    }

public:

    /* properties exported by this interface */
public:

    /* methods exported by this interface,
     * this functions will invoke the corresponding methods on the remote objects
     */
    std::vector< std::string > Cat(const std::string& filename)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filename;
        call.member("Cat");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }

    int32_t Rm(const std::string& filename)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filename;
        call.member("Rm");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    int32_t RmDir(const std::string& foldername)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << foldername;
        call.member("RmDir");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    std::vector< std::string > Ls(const std::string& foldername)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << foldername;
        call.member("Ls");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }

    int32_t MkDir(const std::string& foldername)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << foldername;
        call.member("MkDir");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    int32_t Cp(const std::string& filefrom, const std::string& fileto)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filefrom;
        wi << fileto;
        call.member("Cp");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    int32_t CpDir(const std::string& folderfrom, const std::string& folderto)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << folderfrom;
        wi << folderto;
        call.member("CpDir");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    int32_t Touch(const std::string& filename)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << filename;
        call.member("Touch");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    std::vector< std::string > Find(const std::string& foldername, const bool& throttle)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << foldername;
        wi << throttle;
        call.member("Find");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }

    std::vector< std::string > FindFiles(const std::string& foldername, const bool& throttle)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << foldername;
        wi << throttle;
        call.member("FindFiles");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }

    std::vector< std::string > FindFolders(const std::string& foldername, const bool& throttle)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << foldername;
        wi << throttle;
        call.member("FindFolders");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::vector< std::string > argout;
        ri >> argout;
        return argout;
    }

    std::string Basename(const std::string& itemname)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << itemname;
        call.member("Basename");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::string argout;
        ri >> argout;
        return argout;
    }

    bool Exists(const std::string& itemname)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << itemname;
        call.member("Exists");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        bool argout;
        ri >> argout;
        return argout;
    }

    std::string GetLinkType(const std::string& itemname)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << itemname;
        call.member("GetLinkType");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::string argout;
        ri >> argout;
        return argout;
    }

    int32_t MakeAlias(const std::string& from, const std::string& to, const std::string& kind)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << from;
        wi << to;
        wi << kind;
        call.member("MakeAlias");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }

    std::string ResolveAlias(const std::string& path)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << path;
        call.member("ResolveAlias");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::string argout;
        ri >> argout;
        return argout;
    }

    void LinkGroup(const std::vector< std::string >& from, const std::vector< std::string >& to, const std::vector< std::string >& kind)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << from;
        wi << to;
        wi << kind;
        call.member("LinkGroup");
        ::DBus::Message ret = invoke_method(call);
    }


public:

    /* signal handlers for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual signal handler)
     */
};

} } 
namespace com {
namespace ross {

class settings_proxy
 : public ::DBus::InterfaceProxy
{
public:

    settings_proxy()
    : ::DBus::InterfaceProxy("com.ross.settings")
    {
        connect_signal(settings_proxy, ReloadSettings, _ReloadSettings_stub);
    }

public:

    /* properties exported by this interface */
public:

    /* methods exported by this interface,
     * this functions will invoke the corresponding methods on the remote objects
     */
    void LoadSettings(const std::string& from)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << from;
        call.member("LoadSettings");
        ::DBus::Message ret = invoke_method(call);
    }

    void SaveSettings(const std::string& to)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << to;
        call.member("SaveSettings");
        ::DBus::Message ret = invoke_method(call);
    }

    std::string GetSetting(const std::string& key)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << key;
        call.member("GetSetting");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::string argout;
        ri >> argout;
        return argout;
    }

    void SetSetting(const std::string& key, const std::string& value, const bool& save)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << key;
        wi << value;
        wi << save;
        call.member("SetSetting");
        ::DBus::Message ret = invoke_method(call);
    }

    void DeleteSetting(const std::string& key)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << key;
        call.member("DeleteSetting");
        ::DBus::Message ret = invoke_method(call);
    }

    std::map< std::string, std::string > GetRaw()
    {
        ::DBus::CallMessage call;
        call.member("GetRaw");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        std::map< std::string, std::string > argout;
        ri >> argout;
        return argout;
    }

    void ForceReloadSettings()
    {
        ::DBus::CallMessage call;
        call.member("ForceReloadSettings");
        ::DBus::Message ret = invoke_method(call);
    }


public:

    /* signal handlers for this interface
     */
    virtual void ReloadSettings() = 0;

private:

    /* unmarshalers (to unpack the DBus message before calling the actual signal handler)
     */
    void _ReloadSettings_stub(const ::DBus::SignalMessage &sig)
    {
        ReloadSettings();
    }
};

} } 
namespace com {
namespace ross {

class logger_proxy
 : public ::DBus::InterfaceProxy
{
public:

    logger_proxy()
    : ::DBus::InterfaceProxy("com.ross.logger")
    {
        connect_signal(logger_proxy, DoLog, _DoLog_stub);
    }

public:

    /* properties exported by this interface */
public:

    /* methods exported by this interface,
     * this functions will invoke the corresponding methods on the remote objects
     */
    void Log(const std::string& who, const std::string& what, const int32_t& level=0)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << who;
        wi << what;
        wi << level;
        call.member("Log");
        ::DBus::Message ret = invoke_method(call);
    }

    void Level(const int32_t& level)
    {
        ::DBus::CallMessage call;
        ::DBus::MessageIter wi = call.writer();

        wi << level;
        call.member("Level");
        ::DBus::Message ret = invoke_method(call);
    }

    int32_t GetLevel()
    {
        ::DBus::CallMessage call;
        call.member("GetLevel");
        ::DBus::Message ret = invoke_method(call);
        ::DBus::MessageIter ri = ret.reader();

        int32_t argout;
        ri >> argout;
        return argout;
    }


public:

    /* signal handlers for this interface
     */
    virtual void DoLog(const std::string& who, const std::string& what, const int32_t& level) = 0;

private:

    /* unmarshalers (to unpack the DBus message before calling the actual signal handler)
     */
    void _DoLog_stub(const ::DBus::SignalMessage &sig)
    {
        ::DBus::MessageIter ri = sig.reader();

        std::string who; ri >> who;
        std::string what; ri >> what;
        int32_t level; ri >> level;
        DoLog(who, what, level);
    }
};

} } 
#endif//__dbusxx__client_glue_h__PROXY_MARSHAL_H
