<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libplatform: sqlite3x::sqlite3_connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacesqlite3x.html">sqlite3x</a>::<a class="el" href="classsqlite3x_1_1sqlite3__connection.html">sqlite3_connection</a>
  </div>
</div>
<div class="contents">
<h1>sqlite3x::sqlite3_connection Class Reference</h1><!-- doxytag: class="sqlite3x::sqlite3_connection" --><code>#include &lt;<a class="el" href="sqlite3x_8hpp-source.html">sqlite3x.hpp</a>&gt;</code>
<p>

<p>
<a href="classsqlite3x_1_1sqlite3__connection-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">sqlite3 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#994549daf4faef864d7052d6d28e8afa">db</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#2b6b6ac648502be31801b72efa8e7f44">sqlite3_connection</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#3a56c7fbc21f5d6fb61b899cbc23f315">sqlite3_connection</a> (std::string const &amp;dbname)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#221b3ffd42fea471b899684da2dc8f8a">sqlite3_connection</a> (sqlite3 *dbh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#d3f00600b55ac569393fb261ad46e735">~sqlite3_connection</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#41933079725842d21823e1430d97ca6c">name</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#e0c564c626f5be4f4826cf696f8f2c25">open</a> (char const *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#5327d28557a082e3059cb572c79ef516">open</a> (std::string const &amp;dbname)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#70df03281f7a015938bf414a570ebb07">take</a> (sqlite3 *dbh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">sqlite3 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#9022a895306635cf41436d77a92e54b8">take</a> ()  throw ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#0a41e95412f113d6eaf1272a8f61c9f8">close</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacesqlite3x.html#006a0e90d7b40685893f6f6f766d9b48">int64_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#4d9b082423a6ab8030bd6c0ec820259a">insertid</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#5a043736abe56ac7822d6b8f42295241">changes</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#bd0e42ba45fc51bbb23c4075b32f6f3a">setbusytimeout</a> (int ms)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#3672c874ffecf6f4384bb0f5db34ad97">executenonquery</a> (const std::string &amp;sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#35784fe0742a43b853a9aa3aa5457760">executenonquery</a> (char const *sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#f393283e8a5afe8f03250b46f4427a03">executeint</a> (const std::string &amp;sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#f09cc97864ea41b530c20486147404af">executeint</a> (char const *sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacesqlite3x.html#006a0e90d7b40685893f6f6f766d9b48">int64_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#448fb5ec89a5e17ebbc4b24a4f98cc6f">executeint64</a> (const std::string &amp;sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacesqlite3x.html#006a0e90d7b40685893f6f6f766d9b48">int64_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#1e2bb91b1dbdb27c05f5014db2612e99">executeint64</a> (char const *sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#a58491aa8eaf91ddfbd1f713aa221b83">executedouble</a> (const std::string &amp;sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#40acd14890fc68a42638896091977511">executedouble</a> (char const *sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#c13a519d78685cca4d0749c502169f46">executestring</a> (const std::string &amp;sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#854f001567a08077ff3d6c1670b801a3">executeblob</a> (const std::string &amp;sql)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#ad123d684392949c8ac7867de7e8555e">executecallback</a> (std::string const &amp;sql, sqlite3_callback callback, void *data, std::string &amp;errmsg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#2f3069c45f425bb8d361c40f03ed3679">executecallback</a> (std::string const &amp;sql, sqlite3_callback callback, void *data=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#ac8cae93da50969fa503687566627308">errormsg</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7fa10bd6e0175edf3c27619ba39ec9d6"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::errorcode" ref="7fa10bd6e0175edf3c27619ba39ec9d6" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>errorcode</b> () const </td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsqlite3x_1_1sqlite3__connection.html#3f4b6dca3355274ae73e68f5f7e0eb10">on_open</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cc94d3b7fc3b64e83864dab2f559fbe0"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::sqlite3_command" ref="cc94d3b7fc3b64e83864dab2f559fbe0" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>sqlite3_command</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Represents a connection to an sqlite3 database.<p>
About the only reason to subclass this type would be to do customizations to the underlying sqlite3 db handle upon construction of each object, e.g. to add custom sqlite functions or load custom modules. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="2b6b6ac648502be31801b72efa8e7f44"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::sqlite3_connection" ref="2b6b6ac648502be31801b72efa8e7f44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlite3x::sqlite3_connection::sqlite3_connection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default ctor. DB is unusable until <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#e0c564c626f5be4f4826cf696f8f2c25">open()</a> is called. 
</div>
</div><p>
<a class="anchor" name="3a56c7fbc21f5d6fb61b899cbc23f315"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::sqlite3_connection" ref="3a56c7fbc21f5d6fb61b899cbc23f315" args="(std::string const &amp;dbname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlite3x::sqlite3_connection::sqlite3_connection           </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"> <em>dbname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens a database with the given name. Throws if this-&gt;open(dbname) fails. 
</div>
</div><p>
<a class="anchor" name="221b3ffd42fea471b899684da2dc8f8a"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::sqlite3_connection" ref="221b3ffd42fea471b899684da2dc8f8a" args="(sqlite3 *dbh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlite3x::sqlite3_connection::sqlite3_connection           </td>
          <td>(</td>
          <td class="paramtype">sqlite3 *&nbsp;</td>
          <td class="paramname"> <em>dbh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#70df03281f7a015938bf414a570ebb07">take(sqlite3*)</a>. This ctor is identical except that it throws if passed a null pointer. 
</div>
</div><p>
<a class="anchor" name="d3f00600b55ac569393fb261ad46e735"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::~sqlite3_connection" ref="d3f00600b55ac569393fb261ad46e735" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual sqlite3x::sqlite3_connection::~sqlite3_connection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls this-&gt;<a class="el" href="classsqlite3x_1_1sqlite3__connection.html#0a41e95412f113d6eaf1272a8f61c9f8">close()</a> if <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#0a41e95412f113d6eaf1272a8f61c9f8">close()</a> has not already been called. If it calls <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#0a41e95412f113d6eaf1272a8f61c9f8">close()</a> then the exception is silently ignored for the sake of having a no-throw dtor. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5a043736abe56ac7822d6b8f42295241"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::changes" ref="5a043736abe56ac7822d6b8f42295241" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sqlite3x::sqlite3_connection::changes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of database rows that were changed (or inserted or deleted) by the most recently completed INSERT, UPDATE, or DELETE statement.<p>
SQLite implements the command "DELETE FROM table" without a WHERE clause by dropping and recreating the table. To get an accurate count of the number of rows deleted, use "DELETE FROM table WHERE 1" instead. 
</div>
</div><p>
<a class="anchor" name="0a41e95412f113d6eaf1272a8f61c9f8"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::close" ref="0a41e95412f113d6eaf1272a8f61c9f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sqlite3x::sqlite3_connection::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes this database. If the db is not opened, this is a no-op. 
</div>
</div><p>
<a class="anchor" name="994549daf4faef864d7052d6d28e8afa"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::db" ref="994549daf4faef864d7052d6d28e8afa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlite3* sqlite3x::sqlite3_connection::db           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a handle to the underlying sqlite3 database. Friend classes should NEVER call sqlite3_close() on this handle. Doing so will result in undefined behaviour later on (when this class is used or destructs).<p>
This function is only public so that clients can do things like register new sqlite3 functions with the database. 
</div>
</div><p>
<a class="anchor" name="ac8cae93da50969fa503687566627308"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::errormsg" ref="ac8cae93da50969fa503687566627308" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sqlite3x::sqlite3_connection::errormsg           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the equivalent of sqlite3_errmsg(), or an empty string if that function returns null. Reminder: the sqlite3 docs say that sqlite3_errmsg() always returns a non-empty string, even if the string is "not an error" (no joke). 
</div>
</div><p>
<a class="anchor" name="854f001567a08077ff3d6c1670b801a3"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executeblob" ref="854f001567a08077ff3d6c1670b801a3" args="(const std::string &amp;sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sqlite3x::sqlite3_connection::executeblob           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the query, which is expected to have a string or blob field as the first result field. Note that numeric results can be returned using this function, but will come back as a string (lexically cast). 
</div>
</div><p>
<a class="anchor" name="2f3069c45f425bb8d361c40f03ed3679"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executecallback" ref="2f3069c45f425bb8d361c40f03ed3679" args="(std::string const &amp;sql, sqlite3_callback callback, void *data=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sqlite3x::sqlite3_connection::executecallback           </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"> <em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sqlite3_callback&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience overload which has a default data value of 0 and ignores any error string passed back by sqlite3_exec(). 
</div>
</div><p>
<a class="anchor" name="ad123d684392949c8ac7867de7e8555e"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executecallback" ref="ad123d684392949c8ac7867de7e8555e" args="(std::string const &amp;sql, sqlite3_callback callback, void *data, std::string &amp;errmsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sqlite3x::sqlite3_connection::executecallback           </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"> <em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sqlite3_callback&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>errmsg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the given SQL code, calling callback for each row of the data set. The data pointer is passed on as-is to the callback, and may be 0. If execution generates an error message it is stored in errmsg.<p>
If this function intercepts an exception (thrown from the callback) then it propagates that exception back to the caller. If it catches no exception, it returns the result code, with zero being success and non-zero being failure.<p>
See sqlite3_exec() for more details. 
</div>
</div><p>
<a class="anchor" name="40acd14890fc68a42638896091977511"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executedouble" ref="40acd14890fc68a42638896091977511" args="(char const *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sqlite3x::sqlite3_connection::executedouble           </td>
          <td>(</td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded to avoid an internal copy of sql. sql MUST be non-NULL and null-terminated. 
</div>
</div><p>
<a class="anchor" name="a58491aa8eaf91ddfbd1f713aa221b83"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executedouble" ref="a58491aa8eaf91ddfbd1f713aa221b83" args="(const std::string &amp;sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sqlite3x::sqlite3_connection::executedouble           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the query, which is expected to have a double field as the first result field. 
</div>
</div><p>
<a class="anchor" name="f09cc97864ea41b530c20486147404af"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executeint" ref="f09cc97864ea41b530c20486147404af" args="(char const *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sqlite3x::sqlite3_connection::executeint           </td>
          <td>(</td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded to avoid an internal copy of sql. sql MUST be non-NULL and null-terminated. 
</div>
</div><p>
<a class="anchor" name="f393283e8a5afe8f03250b46f4427a03"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executeint" ref="f393283e8a5afe8f03250b46f4427a03" args="(const std::string &amp;sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sqlite3x::sqlite3_connection::executeint           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the query, which is expected to have an integer field as the first result field. 
</div>
</div><p>
<a class="anchor" name="1e2bb91b1dbdb27c05f5014db2612e99"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executeint64" ref="1e2bb91b1dbdb27c05f5014db2612e99" args="(char const *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesqlite3x.html#006a0e90d7b40685893f6f6f766d9b48">int64_t</a> sqlite3x::sqlite3_connection::executeint64           </td>
          <td>(</td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded to avoid an internal copy of sql. sql MUST be non-NULL and null-terminated. 
</div>
</div><p>
<a class="anchor" name="448fb5ec89a5e17ebbc4b24a4f98cc6f"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executeint64" ref="448fb5ec89a5e17ebbc4b24a4f98cc6f" args="(const std::string &amp;sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesqlite3x.html#006a0e90d7b40685893f6f6f766d9b48">int64_t</a> sqlite3x::sqlite3_connection::executeint64           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the query, which is expected to have a (int64_t) field as the first result field. 
</div>
</div><p>
<a class="anchor" name="35784fe0742a43b853a9aa3aa5457760"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executenonquery" ref="35784fe0742a43b853a9aa3aa5457760" args="(char const *sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sqlite3x::sqlite3_connection::executenonquery           </td>
          <td>(</td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded to avoid an internal copy of sql. sql MUST be non-NULL and null-terminated. 
</div>
</div><p>
<a class="anchor" name="3672c874ffecf6f4384bb0f5db34ad97"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executenonquery" ref="3672c874ffecf6f4384bb0f5db34ad97" args="(const std::string &amp;sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sqlite3x::sqlite3_connection::executenonquery           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes a command which is assumed to have a single step and a void result. 
</div>
</div><p>
<a class="anchor" name="c13a519d78685cca4d0749c502169f46"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::executestring" ref="c13a519d78685cca4d0749c502169f46" args="(const std::string &amp;sql)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sqlite3x::sqlite3_connection::executestring           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>sql</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the query, which is expected to have a string or blob field as the first result field. Note that numeric results can be returned using this function, but will come back as a string (lexically cast). 
</div>
</div><p>
<a class="anchor" name="4d9b082423a6ab8030bd6c0ec820259a"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::insertid" ref="4d9b082423a6ab8030bd6c0ec820259a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesqlite3x.html#006a0e90d7b40685893f6f6f766d9b48">int64_t</a> sqlite3x::sqlite3_connection::insertid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the rowid of the most recently inserted row on this db. 
</div>
</div><p>
<a class="anchor" name="41933079725842d21823e1430d97ca6c"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::name" ref="41933079725842d21823e1430d97ca6c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sqlite3x::sqlite3_connection::name           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns this object's name. It is only valid if the (char const *) ctor or <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#e0c564c626f5be4f4826cf696f8f2c25">open(char const *)</a> was used with a non-null name, otherwise it is an empty string. 
</div>
</div><p>
<a class="anchor" name="3f4b6dca3355274ae73e68f5f7e0eb10"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::on_open" ref="3f4b6dca3355274ae73e68f5f7e0eb10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sqlite3x::sqlite3_connection::on_open           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called when <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#e0c564c626f5be4f4826cf696f8f2c25">open()</a> succeeds. Subclasses which wish to do custom db initialization or sanity checks may do them here. 
</div>
</div><p>
<a class="anchor" name="5327d28557a082e3059cb572c79ef516"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::open" ref="5327d28557a082e3059cb572c79ef516" args="(std::string const &amp;dbname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sqlite3x::sqlite3_connection::open           </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"> <em>dbname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Functionally the same as <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#e0c564c626f5be4f4826cf696f8f2c25">open( char const *)</a>. 
</div>
</div><p>
<a class="anchor" name="e0c564c626f5be4f4826cf696f8f2c25"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::open" ref="e0c564c626f5be4f4826cf696f8f2c25" args="(char const *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sqlite3x::sqlite3_connection::open           </td>
          <td>(</td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates/opens the given db, throwing on error. Remember that sqlite3 supports the name ":memory:" as a pseudo-name for an in-memory database.<p>
On success it returns, else it throws.<p>
Note that sqlite3 supports the special db name ":memory:" to represent an in-memory database. Such databases cannot be saved directly to disk and are lost when this object closes the db.<p>
Internal notes:<p>
Once an sqlite3_open() succeeds, the protected member this-&gt;<a class="el" href="classsqlite3x_1_1sqlite3__connection.html#3f4b6dca3355274ae73e68f5f7e0eb10">on_open()</a> in called. That member should throw on error.<p>
Subclasses which override this and do not want to call the base implementation should call <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#3f4b6dca3355274ae73e68f5f7e0eb10">on_open()</a> when done to allow subclasses to initialize the database if they like. 
</div>
</div><p>
<a class="anchor" name="bd0e42ba45fc51bbb23c4075b32f6f3a"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::setbusytimeout" ref="bd0e42ba45fc51bbb23c4075b32f6f3a" args="(int ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sqlite3x::sqlite3_connection::setbusytimeout           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ms</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See sqlite3_busy_timeout(). 
</div>
</div><p>
<a class="anchor" name="9022a895306635cf41436d77a92e54b8"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::take" ref="9022a895306635cf41436d77a92e54b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sqlite3* sqlite3x::sqlite3_connection::take           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transfers ownership of the returned handle to the caller. This object is then considered closed. NULL is returned if this object is closed. 
</div>
</div><p>
<a class="anchor" name="70df03281f7a015938bf414a570ebb07"></a><!-- doxytag: member="sqlite3x::sqlite3_connection::take" ref="70df03281f7a015938bf414a570ebb07" args="(sqlite3 *dbh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sqlite3x::sqlite3_connection::take           </td>
          <td>(</td>
          <td class="paramtype">sqlite3 *&nbsp;</td>
          <td class="paramname"> <em>dbh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transfers control of dbh to this object and makes this object point at dbh. dbh is assumed to be a valid, opened sqlite3 db handle.<p>
If this-&gt;<a class="el" href="classsqlite3x_1_1sqlite3__connection.html#994549daf4faef864d7052d6d28e8afa">db()</a> == dbh then this function does nothing.<p>
If this object had an opened db handle then it is closed before dbh is taken. Closing may throw, but this function takes ownership of dbh regardless of whether it throws or not.<p>
If dbh is null, the effect is identical to calling <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#0a41e95412f113d6eaf1272a8f61c9f8">close()</a>.<p>
This function triggers the protected <a class="el" href="classsqlite3x_1_1sqlite3__connection.html#3f4b6dca3355274ae73e68f5f7e0eb10">on_open()</a> function if dbh is not null. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>/Users/r0ssar00/Development/Git/platform/platform/<a class="el" href="sqlite3x_8hpp-source.html">sqlite3x.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jul 29 03:11:54 2009 for libplatform by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
